我理解了问题所在。当在 `reporting_center` 列中存在相同ID时，排序会出现问题。以下是修复后的代码，确保按照指定的三个主键列（`reporting_center`, `investment_fund_code`, `benefit_account`）进行稳定排序：

```python
# 安装必要库 (首次运行需取消注释)
# !pip install pandas numpy openpyxl

import pandas as pd
import numpy as np
from IPython.display import display, Markdown

# ========================
# 步骤1: 生成模拟测试数据 (包含三个主键列)
# ========================
def generate_fake_data(num_rows=10):
    """创建包含空值和特殊字符的测试数据"""
    np.random.seed(42)
    
    # 创建三个主键列 - 确保有部分重复值
    reporting_center = np.random.choice(['RC001', 'RC002', 'RC003', 'RC004', 'RC001'], num_rows)
    investment_fund_code = np.random.choice(['IF100', 'IF200', 'IF300', 'IF100', 'IF200'], num_rows)
    benefit_account = np.random.choice(['BA01', 'BA02', 'BA03', 'BA01', 'BA02'], num_rows)
    
    data = {
        'reporting_center': reporting_center,
        'investment_fund_code': investment_fund_code,
        'benefit_account': benefit_account,
        # 带空值的整数列
        'A': np.random.choice([1, 2, 3, np.nan, ''], num_rows),
        # 带空字符串和单引号的文本列
        'B': np.random.choice(['apple', "o'connor", 'banana', '', 'cherry'], num_rows),
        # 带空值的浮点数列
        'C': np.round(np.random.uniform(10, 100, num_rows), 2)
    }
    
    # 随机插入空字符串
    for col in ['B']:
        data[col] = [v if np.random.rand() > 0.3 else '' for v in data[col]]
    
    return pd.DataFrame(data)

# 生成测试数据 (10行示例)
df = generate_fake_data()
display(Markdown("**生成的测试数据 (包含重复的主键值):**"))
display(df)

# ====================================================
# 步骤2: 核心功能 - 转换Excel数据为SQL插入语句 (修复排序问题)
# ====================================================
def df_to_sql(df, table_name="test", primary_keys=['reporting_center', 'investment_fund_code', 'benefit_account']):
    """将DataFrame转换为SQL插入语句，按主键排序"""
    # 1. 按主键列排序
    try:
        # 确保所有主键列都存在
        missing_keys = [key for key in primary_keys if key not in df.columns]
        if missing_keys:
            raise ValueError(f"以下主键列不存在: {missing_keys}")
            
        # 按主键排序（稳定排序）
        sorted_df = df.sort_values(by=primary_keys, kind='mergesort')
    except Exception as e:
        print(f"排序错误: {str(e)} - 使用原始顺序")
        sorted_df = df
    
    # 2. 处理列名
    columns = ', '.join([f'"{col}"' for col in sorted_df.columns])  # 添加引号防止特殊字符问题
    
    # 3. 生成值列表
    value_rows = []
    for _, row in sorted_df.iterrows():
        values = []
        for val in row:
            # 处理空值和空字符串
            if pd.isna(val) or val == '':
                values.append("NULL")
            # 处理字符串 (转义单引号)
            elif isinstance(val, str):
                val_escaped = val.replace("'", "''")
                values.append(f"'{val_escaped}'")
            # 处理数值类型
            elif isinstance(val, (int, float)):
                values.append(str(val))
            # 处理其他类型 (如布尔值)
            else:
                values.append(f"'{str(val)}'")
        
        value_rows.append(f"({', '.join(values)})")
    
    # 4. 构建完整SQL语句
    sql = f"INSERT INTO {table_name} ({columns})\nVALUES\n"
    sql += ',\n'.join(value_rows) + ';'
    return sql

# ========================
# 步骤3: 执行转换并显示
# ========================
# 从DataFrame直接转换
table_name = "test"
primary_keys = ['reporting_center', 'investment_fund_code', 'benefit_account']

sql_output = df_to_sql(df, table_name, primary_keys)

display(Markdown("**生成的SQL语句 (按主键排序):**"))
display(Markdown(f"```sql\n{sql_output}\n```"))

# ===================================
# 可选功能: 从Excel文件读取
# ===================================
def excel_to_sql(file_path, sheet_name, table_name, primary_keys):
    """从Excel文件读取并生成SQL，按主键排序"""
    try:
        df = pd.read_excel(file_path, sheet_name=sheet_name)
        return df_to_sql(df, table_name, primary_keys)
    except Exception as e:
        return f"错误: {str(e)}"

# 使用示例 (取消注释运行)
# final_sql = excel_to_sql(
#     file_path="your_file.xlsx",
#     sheet_name="Sheet1",
#     table_name="your_table",
#     primary_keys=['reporting_center', 'investment_fund_code', 'benefit_account']
# )
# display(Markdown(f"```sql\n{final_sql}\n```"))
```

### 主要修复和改进：

1. **主键排序问题修复**：
   - 添加了 `primary_keys` 参数，明确指定排序依据的列
   - 使用 `sort_values(by=primary_keys, kind='mergesort')` 进行稳定排序
   - 添加了错误处理，当主键列不存在时提供明确错误信息

2. **测试数据增强**：
   - 生成包含重复主键值的测试数据（`reporting_center`, `investment_fund_code`, `benefit_account`）
   - 确保排序功能可以处理重复值情况

3. **排序稳定性**：
   - 使用 `kind='mergesort'` 确保当主键值相同时，保持原始数据顺序
   - 这对于处理相同主键值的多行数据非常重要

4. **完整的错误处理**：
   - 检查所有主键列是否存在于DataFrame中
   - 捕获排序过程中的任何异常，并提供回退方案

### 使用说明：

1. **指定主键列**：
   ```python
   primary_keys = ['reporting_center', 'investment_fund_code', 'benefit_account']
   sql_output = df_to_sql(df, "test", primary_keys)
   ```

2. **从Excel文件读取**：
   ```python
   final_sql = excel_to_sql(
       file_path="your_data.xlsx",
       sheet_name="Sheet1",
       table_name="financial_data",
       primary_keys=['reporting_center', 'investment_fund_code', 'benefit_account']
   )
   ```

3. **输出特点**：
   - SQL语句中的行按指定主键排序
   - 相同主键值的行保持它们在原始数据中的相对顺序
   - 特殊字符和空值被正确处理

这个修复版本专门解决了当主键列中存在相同值时出现的排序问题，并确保按照要求的三个主键列进行稳定排序。





以下是根据您的要求构建的复杂SQL查询代码，实现了多表关联和复合筛选逻辑：

```sql
-- 定义报告生成日期变量 (根据实际需求设置)
DECLARE @ReportGenerationDate DATE = GETDATE();

SELECT 
    -- 选择需要的列 (根据实际需求调整)
    a.*,
    f.*,
    m.date_of_birth,
    DATEADD(YEAR, 60, m.date_of_birth) AS dob_plus_60,
    DATEFROMPARTS(YEAR(DATEADD(YEAR, 60, m.date_of_birth)), 
                   MONTH(DATEADD(YEAR, 60, m.date_of_birth)), 
                   1) AS first_day_after_60
FROM 
    DWH.dbo.tb_member_account m
INNER JOIN 
    DWH.dbo.ra_rebate_details_account a 
    ON m.mbr_acct_cd = a.member_account_code
    AND m.DELETE_FLAG = 'N'
    AND a.DELETE_FLAG = 'N'
INNER JOIN 
    DWH.dbo.ra_rebate_details_funds f 
    ON a.employer_account_code = f.employer_account_code
    AND a.member_account_code = f.member_account_code
    AND f.DELETE_FLAG = 'N'
WHERE 
    -- 条件1: account_type = 'ER'
    (a.account_type = 'ER')
    
    OR 
    -- 条件2: account_type 非特定值 AND fund_code 非特定值
    (a.account_type NOT IN ('ER', 'REE', 'CEE')
    AND f.fund_code NOT IN ('SLMIF', 'SLMIF-B'))
    
    OR 
    -- 条件3: account_type 非特定值 AND fund_code 为特定值 AND 年龄条件
    (a.account_type NOT IN ('ER', 'REE', 'CEE')
    AND f.fund_code IN ('SLMIF', 'SLMIF-B')
    AND DATEFROMPARTS(
            YEAR(DATEADD(YEAR, 60, m.date_of_birth)), 
            MONTH(DATEADD(YEAR, 60, m.date_of_birth)), 
            1
        ) > @ReportGenerationDate
    );
```

### 关键逻辑解释：

1. **表关联顺序**：
   - 首先将 `tb_member_account` (别名 `m`) 与 `ra_rebate_details_account` (别名 `a`) 通过 `mbr_acct_cd = member_account_code` 关联
   - 然后将结果与 `ra_rebate_details_funds` (别名 `f`) 通过 `(employer_account_code, member_account_code)` 关联

2. **删除标志过滤**：
   ```sql
   AND m.DELETE_FLAG = 'N'
   AND a.DELETE_FLAG = 'N'
   AND f.DELETE_FLAG = 'N'
   ```

3. **三个主要条件 (OR关系)**：
   - **条件1**：`account_type = 'ER'`
     ```sql
     (a.account_type = 'ER')
     ```
   
   - **条件2**：非特定账户类型 + 非特定基金代码
     ```sql
     (a.account_type NOT IN ('ER', 'REE', 'CEE')
     AND f.fund_code NOT IN ('SLMIF', 'SLMIF-B'))
     ```
   
   - **条件3**：非特定账户类型 + 特定基金代码 + 年龄条件
     ```sql
     (a.account_type NOT IN ('ER', 'REE', 'CEE')
     AND f.fund_code IN ('SLMIF', 'SLMIF-B')
     AND DATEFROMPARTS(...) > @ReportGenerationDate)
     ```

4. **复杂日期计算**：
   - 计算60岁生日：`DATEADD(YEAR, 60, m.date_of_birth)`
   - 获取60岁生日当月第一天：
     ```sql
     DATEFROMPARTS(
         YEAR(DATEADD(YEAR, 60, m.date_of_birth)), 
         MONTH(DATEADD(YEAR, 60, m.date_of_birth)), 
         1
     )
     ```
   - 比较该日期是否大于报告生成日期

### 优化建议：

1. **创建计算列索引**：
   如果频繁使用年龄计算，考虑在表中添加持久化计算列：
   ```sql
   ALTER TABLE tb_member_account
   ADD dob_plus_60_first_day AS 
       CAST(DATEFROMPARTS(YEAR(DATEADD(YEAR, 60, date_of_birth)), 
                         MONTH(DATEADD(YEAR, 60, date_of_birth)), 
                         1) AS DATE) PERSISTED;
   
   CREATE INDEX IX_dob_60 ON tb_member_account(dob_plus_60_first_day);
   ```

2. **参数化报告日期**：
   ```sql
   CREATE PROCEDURE GenerateRebateReport
       @ReportDate DATE
   AS
   BEGIN
       -- 上述查询代码，使用@ReportDate替换@ReportGenerationDate
   END
   ```

3. **性能优化**：
   - 在连接字段上创建索引：
     ```sql
     CREATE INDEX IX_mbr_acct ON tb_member_account(mbr_acct_cd) INCLUDE (date_of_birth);
     CREATE INDEX IX_acc_codes ON ra_rebate_details_account(employer_account_code, member_account_code);
     CREATE INDEX IX_fund_codes ON ra_rebate_details_funds(fund_code, employer_account_code, member_account_code);
     ```
   - 过滤索引：
     ```sql
     CREATE INDEX IX_active_accounts ON ra_rebate_details_account(account_type) 
     WHERE DELETE_FLAG = 'N';
     ```

### 注意事项：
1. 日期计算假设使用SQL Server语法，其他数据库需调整日期函数
2. `DATEFROMPARTS` 需要SQL Server 2012+，旧版本使用：
   ```sql
   DATEADD(DAY, 1, EOMONTH(DATEADD(YEAR, 60, m.date_of_birth), -1))
   ```
3. 确保所有表位于同一数据库和schema（示例使用`DWH.dbo`）
4. 实际使用时替换`SELECT *`为具体需要的列名

此查询实现了您要求的复杂逻辑，包括多表连接、复合条件筛选和特殊日期计算，同时考虑了性能优化和可维护性。
