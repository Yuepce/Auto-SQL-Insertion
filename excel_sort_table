✅ 解决方法（推荐方案）：

使用 Pandas 的显示设置 pd.set_option() 来控制显示宽度、列数、是否截断等。

⸻

✅ 修改后的代码（附加显示设置）：

import pandas as pd
from io import StringIO

def restore_order_from_text(table_a_text: str, table_b_text: str, key_columns: list) -> pd.DataFrame:
    """
    将表B按表A的指定列顺序还原，支持Excel复制的文本输入。
    """

    # 设置显示选项：不折行、不截断、显示所有列
    pd.set_option('display.max_columns', None)       # 显示所有列
    pd.set_option('display.expand_frame_repr', False)  # 不自动换行
    pd.set_option('display.max_colwidth', None)       # 列内容不截断
    pd.set_option('display.width', 2000)              # 控制行宽，防止 \ 折行

    # 读取两份表格数据（制表符分隔）
    df_a = pd.read_csv(StringIO(table_a_text), sep='\t')
    df_b = pd.read_csv(StringIO(table_b_text), sep='\t')

    # 添加顺序编号到A
    df_a["_original_order"] = range(len(df_a))

    # 将顺序merge到B，并按顺序排序
    df_b_sorted = df_b.merge(
        df_a[key_columns + ["_original_order"]],
        on=key_columns,
        how="left"
    ).sort_values(by="_original_order")

    # 删除排序辅助列
    df_b_sorted = df_b_sorted.drop(columns=["_original_order"])

    return df_b_sorted


⸻

✅ 使用时保持输出完整：

# 打印完整 DataFrame，不换行、不折断
print(restore_order_from_text(table_a_text, table_b_text, ["employer_account_code", "member_account_code"]))


⸻

✅ 或者你也可以保存为 Excel：

restore_order_from_text(table_a_text, table_b_text, ["employer_account_code", "member_account_code"]) \
    .to_excel("restored_output.xlsx", index=False)

